<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Projects on Chris Woodall</title><link>/projects/</link><description>Recent content in Projects on Chris Woodall</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 01 Dec 2013 01:29:18 +0000</lastBuildDate><atom:link href="/projects/index.xml" rel="self" type="application/rss+xml"/><item><title>Simplified X86 Assembler and Emulator</title><link>/projects/2014-02-03-sx86-emulator/</link><pubDate>Sun, 01 Dec 2013 01:29:18 +0000</pubDate><guid>/projects/2014-02-03-sx86-emulator/</guid><description>&lt;p>While at BU I had an assignment for a class called EC327 which used a 16-bit
RISC processor that the professors called &amp;ldquo;simplified x86&amp;rdquo;, also referred to as
sx86. This was a very basic assembler, and the tool at the time was written in
java, but had some issues with copying code in and out of the program requiring
that you hand copy the code. To make my debugging easier I implemented an emulator
in Javascript (it should be a valid node.js program), and then a front end to
view the data. I had also written a python script to assemble and dissassemble
these instructions and later integrated a TA for the classes code with mine to
create a CGI based set of calls to assemble and dissassemble the code. I learned
a whole lot more from this project than I would have otherwise, just converting
some machine code by hand and chugging along. This website was used by EC327 for
one or two years after the fact (and may still be today, I have no idea).&lt;/p></description></item><item><title>16 Channel 12-bit Floating Fine Adjustment DAC</title><link>/projects/2013-07-30-16-channel-floating-dac/</link><pubDate>Wed, 28 Aug 2013 01:29:18 +0000</pubDate><guid>/projects/2013-07-30-16-channel-floating-dac/</guid><description/></item><item><title>Artemis Synthesizer v2: Digital Audio Synthesizer Kit</title><link>/projects/2013-07-28-artemis-synth-v2/</link><pubDate>Mon, 29 Jul 2013 01:29:18 +0000</pubDate><guid>/projects/2013-07-28-artemis-synth-v2/</guid><description>&lt;p>The Artemis Synthesizer is a digital audio synthesizer kit developed in my spare time with help from the &lt;a href="http://edf.bu.edu">BU Electronic Design Facility&lt;/a>. The kits purpose was to help teach a group of female high school freshmen in the &lt;a href="http://www.bu.edu/lernet/artemis/">Artemis&lt;/a> summer program how to solder. Assembly was designed to take between 2 and 4 hours for a beginner, but should take closer to 30 minutes for someone with prior experience.&lt;/p>
&lt;p>The synthesizer utilizes an ATMega328 and a 12-bit DAC to produce the audio, in its default mode you can play 4 different 8 note scales. There is also a sequencer mode and an ability to change the waveform. To load sequences and new waveforms the &lt;a href="http://cwoodall.github.io/artemis-synth">optoloader&lt;/a> interface is used, which uses javascript to blink a black square on a computer screen and a phototransistor to receive this message, which is then decoded on the microcontroller.&lt;/p></description></item><item><title>TTT: TTC TTS Tester for CMS and G minus 2</title><link>/projects/2013-07-29-ttt/</link><pubDate>Sun, 30 Jun 2013 01:29:18 +0000</pubDate><guid>/projects/2013-07-29-ttt/</guid><description>&lt;p>The TTT is a piece of test equipment design for &lt;a href="http://cms.web.cern.ch/">CMS&lt;/a> through the &lt;a href="http://edf.bu.edu">BU Electronic Design Facility&lt;/a> (EDF). Its main function is to generate L1A (Level-1 Accept) trigger events and stream them to another piece of equipment and listen to that piece of equipment to see if its buffer is full.&lt;/p>
&lt;p>The TTT runs a &lt;a href="http://xilinx.com/">Xilinx&lt;/a> Spartan-6 FPGA, with an Ethernet MAC I wrote, and communicates with a PC using a protocol called &lt;a href="https://svnweb.cern.ch/trac/cactus/wiki">IPBus&lt;/a>. This allows for configurations to be set, such as, running off of an external clock. The board to board communications are done over a fiber optic interface and the Spartan-6 chip decodes an 80MHz BiPhase Mark Coded datastream which multiplexes two datastreams together.&lt;/p></description></item><item><title>Monophonic Analog Synthesizer with AR Enveloping</title><link>/projects/2013-07-27-analog-synth-ec412/</link><pubDate>Sun, 21 Apr 2013 01:29:18 +0000</pubDate><guid>/projects/2013-07-27-analog-synth-ec412/</guid><description>&lt;p>This Monophonic Analog Synthesizer was designed by Christopher Woodall and Benjamin Havey. The synthesizer uses a homemade linearly actuated potentiometer as its input, a long with a button for articulation. The potentiometer voltage is fed through a linear to exponential converter and then a voltage controlled oscillator. The output of the VCO is then put through a analog multiplier designed using an opamp and discrete transistors which envelopes the square and triangle wave VCO outputs with a attack release (AR) envelope. The enveloped output is then filtered, amplified and pumped through speakers. Each piece of the synthesizer was simulated in LTSpice and then built on a breadboard.&lt;/p></description></item><item><title>Object Detecting Laser Turret</title><link>/projects/2013-07-26-laser-turret-for-ec535/</link><pubDate>Sat, 20 Apr 2013 01:29:18 +0000</pubDate><guid>/projects/2013-07-26-laser-turret-for-ec535/</guid><description>&lt;p>The Laser Turret uses a webcam to track objects and then shoots a laser in the direction of the tracked object. The goal of is to process the images taken by the webcam and, using the results that comes from processing the images, control the servo motors appropriately to direct the beam of laser at the object. In the time given, we were able to accomplish the goals that we set for ourselves. Using only the gumstix board, we were able to successfully interface with the webcam and process the images taken. We were also able to provide the proper pulse width modulations to the servo motors to correctly aim the laser at the target that the webcam processed.&lt;/p></description></item><item><title>Firestarter v1: Hybrid Rocket Pressure Monitor &amp;amp; Igniter</title><link>/projects/2013-07-29-firestarter/</link><pubDate>Fri, 15 Mar 2013 01:29:18 +0000</pubDate><guid>/projects/2013-07-29-firestarter/</guid><description>&lt;p>Firestarter v1 was designed to open a pyro valve, preheat the fuel grain, and monitor the combustion chamber and N2O tank pressures for the &lt;a href="http://www.burocket.org/">BU Rocket Propulsion Group&lt;/a>&amp;rsquo;s MkIII hybrid rocket engine. The pressure readings are all from full bridge pressure transducers which go through an instrumentation amplifier, 4th order Butterwirth filter and into an ADC. The board communicates to the world through and RS-422 connection and runs on STM32 Cortex-M3 microcontroller. More explicit information is not available due to various restrictions.&lt;/p></description></item><item><title>builds.cc v2</title><link>/projects/2013-08-15-builds-website/</link><pubDate>Wed, 15 Aug 2012 01:29:18 +0000</pubDate><guid>/projects/2013-08-15-builds-website/</guid><description/></item><item><title>NES Controller Controlled LED Cube</title><link>/projects/2013-08-30-nes-controlled-led-cube/</link><pubDate>Wed, 01 Feb 2012 01:29:18 +0000</pubDate><guid>/projects/2013-08-30-nes-controlled-led-cube/</guid><description/></item><item><title>Twelve Ounce: A Low-Cost Robot for Experimentation</title><link>/projects/2013-07-30-twelve-ounce/</link><pubDate>Wed, 01 Feb 2012 01:29:18 +0000</pubDate><guid>/projects/2013-07-30-twelve-ounce/</guid><description/></item><item><title>C4: Connect 4 Android Game</title><link>/projects/2013-07-30-c4-android/</link><pubDate>Thu, 15 Dec 2011 01:29:18 +0000</pubDate><guid>/projects/2013-07-30-c4-android/</guid><description>&lt;p>Have you ever wanted to Connect Four red or blue disks on a yellow background? Now is your chance! This implementation of the fun and traditional game utilizes the Android NDK, a C++ backend and the native Java SDK.&lt;/p>
&lt;p>Play single player, against a silly AI, or against a Friend in an epic duel of the whits.&lt;/p></description></item><item><title>NOMIS: Simon Memory Game Clone</title><link>/projects/2013-07-30-nomis/</link><pubDate>Tue, 01 Feb 2011 01:29:18 +0000</pubDate><guid>/projects/2013-07-30-nomis/</guid><description>&lt;p>Nomis is a Simon-like memory game for the ATTiny85, which uses the ATTiny85. The game logic in the ATTiny85 was implemented using AVR C and takes up 983 bytes in program memory and 6 bytes in data memory. The implementation size comes in under 1kB, but could most certainly be smaller. The pin usage, however, is very conservative and the games electronics take up a total of 4 of the 6 available pins. The 4 LEDs are controlled on 3 pins using Charlieplexing model (which could easily be extended to 6 LEDs). On the other hand the 4 pushbutton switches are feed into an ADC input through an R2R ladder configuration. I am very happy with the limited pin usage of this project.&lt;/p></description></item></channel></rss>